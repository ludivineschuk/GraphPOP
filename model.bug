var
    nDemes,     # nombre de demes (729) 
    nDates,     # nombre de dates dans larveSizes  
    Demes,      # vecteur contenant des numeros de demes (recovery)
    Dates,      # vecteur contenant des numeros de dates (recovery)
    birthDates, # vecteurs contenant les numeros de dates de naissance

    x.K[nDates,nDemes], 
    x.R[nDates,nDemes],
    slope.K[nDates,nDemes],
    slope.R[nDates,nDemes],

    parentSizes[nDates,nDemes],
    larveSizes[nDates,nDemes],
    migrationMatrix[nDemes,nDemes];



model {

    # ------------------------------------------------------------
    # PRIORS
    #

    K.pr.X0 ~ dnorm(0,1)
    K.pr.Xopt ~ dnorm(1,38)
    K.pr.Yopt ~ dnorm(11,5)


    R.pr.X0 ~ dnorm(0,1)
    R.pr.Xopt ~ dnorm(1,38)
    R.pr.Yopt ~ dnorm(5,2)

    generation ~ dnorm(generationTime, generationTimeSD)
    tempsVie ~ dnorm(dvlpTime, dvlpTimeSD) 



    # ------------------------------------------------------------
    # CALCUL DES ATTENDUS
    #

    # Initialisation des parametres

    dispersionRate <- 0.025
    dispersionDistance <- 100
    generationTime <- 25
    generationTimeSD <- 3
    dvlpTime <- 5
    dvlpTimeSD <- 1

    # Initialisation de la matrice de migration

    for(i in 1:nDemes) {
        for(j in 1:nDemes) {
            migrationMatrix[i,j] <- ifelse(equals(distMat[i,j],0), 0, 1) * step(dispersionDistance-distMat[i,j]) * dispersionRate + equals(distMat[i,j],0) * (1-dispersionRate*4)
        }
    }

    # Initialisation de la matrice des parents et des larves

    for(i in 1:nDemes) {
        parentSizes[1,i] <- 1#dnorm(1,0)
        larveSizes[1,i] <- 0#dnorm(0,0)
    }


    # Calcul des individus attendus

    for(i in 2:nDates) {

        # Evaluation de K et R

        for(j in 1:nDemes) {
            # pour le step: mettre le plus grand en premier
            x.K[i,j] <- EnvData[j,i,1]
            slope.K[i,j] <- K.pr.Yopt/(K.pr.Xopt-K.pr.X0)
            Y.K[i,j] <- (slope.K[i,j] * x.K[i,j] - slope.K[i,j] * K.pr.X0)
            Y.Kbis[i,j] <- ifelse((K.pr.Xopt-K.pr.X0)!=0, step(K.pr.Yopt-Y.K[i,j])*Y.K[i,j]*step(Y.K[i,j])+K.pr.Yopt*step(Y.K[i,j]-K.pr.Yopt), K.pr.Yopt*step(x.K[i,j]-K.pr.Xopt))
            K[i,j] <- Y.Kbis[i,j]
            #K[i,j] <- ifelse(equals(Y.Kbis[i,j],NA), 0, 1) * Y.Kbis[i,j]
            # FORMATER LES DONNEES POUR ENLEVER LES NA


            x.R[i,j] <- EnvData[j,i,1]
            slope.R[i,j] <- R.pr.Yopt/(R.pr.Xopt-R.pr.X0)
            Y.R[i,j] <- (slope.R[i,j] * x.R[i,j] - slope.R[i,j] * R.pr.X0)
            Y.Rbis[i,j] <- ifelse((R.pr.Xopt-R.pr.X0)!=0, step(R.pr.Yopt-Y.R[i,j])*Y.R[i,j]*step(Y.R[i,j])+R.pr.Yopt*step(Y.R[i,j]-R.pr.Yopt), R.pr.Yopt*step(x.R[i,j]-R.pr.Xopt))
            R[i,j] <- Y.Rbis[i,j]
            #R[i,j] <- ifelse(equals(Y.Rbis[i,j],NA), 0, 1) * Y.Rbis[i,j]          
        }        


        

        # Migration des adultes

        parentSizes[i,] <- ifelse(parentSizes[i-1,] + (parentSizes[i-1,]%*%migrationMatrix) < 0, 0, parentSizes[i-1,] + (parentSizes[i-1,]%*%migrationMatrix))



        for(j in 1:nDemes) {
            larveSizes[i,j] <- ifelse(i-round(generation)<=0, larveSizes[i-1,j], larveSizes[i-1,j] + larveSizes[i-1,j] * R[i,j] - larveSizes[i-round(generation),j] * R[i-round(generation),j])
            parentSizes[i,j] <- ifelse(i-round(generation)<=0 && i-round(tempsVie)<=0, parentSizes[i-1,j], parentSizes[i-1,j] + larveSizes[i-round(generation),j] * R[i-round(generation),j] - parentSizes[i-round(tempsVie),j] * R[i-round(tempsVie),j])
        }

    }






    # ------------------------------------------------------------
    # LIKELIHOOD
    #


      


}