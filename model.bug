var
    nDemes,     # nombre de demes (729) 
    nDates,     # nombre de dates dans larveSizes  
    Demes,      # vecteur contenant des numeros de demes (recovery)
    Dates,      # vecteur contenant des numeros de dates (recovery)
    nReco,     # nombre de lignes dans recovery

    x.K[nDates,nDemes], 
    x.R[nDates,nDemes],
    slope.K[nDates,nDemes],
    slope.R[nDates,nDemes],

    parentSizes[nDates,nDemes],
    parentSizesMigr[nDates,nDemes],
    larveSizes[nDates,nDemes],
    migrationMatrix[nDemes,nDemes];



model {

    # ------------------------------------------------------------
    # PRIORS
    #

    K.pr.X0 ~ dnorm(0,1)
    K.pr.Xopt ~ dnorm(1,38)
    K.pr.Yopt ~ dnorm(11,5)


    R.pr.X0 ~ dnorm(0,1)
    R.pr.Xopt ~ dnorm(1,38)
    R.pr.Yopt ~ dnorm(5,2)





    # ------------------------------------------------------------
    # CALCUL DES ATTENDUS
    #

    # Initialisation des parametres

    dispersionRate <- 0.025
    dispersionDistance <- 100
    generationTime <- 25
    generationTimeSD <- 3
    dvlpTime <- 5
    dvlpTimeSD <- 1

    # Initialisation de la matrice de migration

    for(i in 1:nDemes) {
        for(j in 1:nDemes) {
            migrationMatrix[i,j] <- ifelse(equals(distMat[i,j],0), 0, 1) * step(dispersionDistance-distMat[i,j]) * dispersionRate + equals(distMat[i,j],0) * (1-dispersionRate*4)
        }
    }

    # Initialisation des variables

    for(i in 1:nDemes) {
        parentSizes[1,i] <- 1
        parentSizesMigr[1,i] <- 1
        larveSizes[1,i] <- 0
        K[1,i] <- 0.01
        R[1,i] <- 0.01
        generation[1,i] <- 25
        tempsVie[1,i] <- 5
    }

 


    # Calcul des individus attendus
    for(i in 2:nDates) {

        # Evaluation de K et R

        for(j in 1:nDemes) {
            # pour le step: mettre le plus grand en premier
            x.K[i,j] <- EnvData[j,i,1]
            slope.K[i,j] <- K.pr.Yopt/(K.pr.Xopt-K.pr.X0)
            Y.K[i,j] <- (slope.K[i,j] * x.K[i,j] - slope.K[i,j] * K.pr.X0)
            Y.Kbis[i,j] <- ifelse((K.pr.Xopt-K.pr.X0)!=0, step(K.pr.Yopt-Y.K[i,j])*Y.K[i,j]*step(Y.K[i,j])+K.pr.Yopt*step(Y.K[i,j]-K.pr.Yopt), K.pr.Yopt*step(x.K[i,j]-K.pr.Xopt))
            K[i,j] <- Y.Kbis[i,j]
            #K[i,j] <- ifelse(equals(Y.Kbis[i,j],NA), 0, 1) * Y.Kbis[i,j]
            # FORMATER LES DONNEES POUR ENLEVER LES NA


            x.R[i,j] <- EnvData[j,i,1]
            slope.R[i,j] <- R.pr.Yopt/(R.pr.Xopt-R.pr.X0)
            Y.R[i,j] <- (slope.R[i,j] * x.R[i,j] - slope.R[i,j] * R.pr.X0)
            Y.Rbis[i,j] <- ifelse((R.pr.Xopt-R.pr.X0)!=0, step(R.pr.Yopt-Y.R[i,j])*Y.R[i,j]*step(Y.R[i,j])+R.pr.Yopt*step(Y.R[i,j]-R.pr.Yopt), R.pr.Yopt*step(x.R[i,j]-R.pr.Xopt))
            R[i,j] <- Y.Rbis[i,j]
            #R[i,j] <- ifelse(equals(Y.Rbis[i,j],NA), 0, 1) * Y.Rbis[i,j]          
        }        

        # Migration, reproduction et mort

        parentSizesMigr[i,] <- ifelse(parentSizes[i-1,] + (parentSizes[i-1,]%*%migrationMatrix) < 0, 0, parentSizes[i-1,] + (parentSizes[i-1,]%*%migrationMatrix))

        

        for(j in 1:nDemes) {
            generation[i,j] <- 25
            tempsVie[i,j] <- 5
            larveSizes[i,j] <- larveSizes[i-1,j] + larveSizes[i-1,j] * R[i,j] - larveSizes[ifelse((i-round(generation[i,j]))<=0,i-1,(i-round(generation[i,j]))),j] * R[ifelse((i-round(generation[i,j]))<=0,i-1,(i-round(generation[i,j]))),j]
            parentSizes[i,j] <- parentSizesMigr[i-1,j] + larveSizes[ifelse((i-round(generation[i,j]))<=0,i-1,(i-round(generation[i,j]))),j] * R[ifelse((i-round(generation[i,j]))<=0,i-1,(i-round(generation[i,j]))),j] - parentSizesMigr[ifelse((i-round(tempsVie[i,j]))<=0,i-1,(i-round(tempsVie[i,j]))),j] * R[ifelse((i-round(tempsVie[i,j]))<=0,i-1,(i-round(tempsVie[i,j]))),j]
        }

    }

#Comparaison entre recovery et larve sizes pour ne garder que les adequats
    for (i in 1:nReco){
        sims[i] <- larveSizes[recovery[i,1], recovery[i,3]]
    }


#formatage sous forme de ligne



    # ------------------------------------------------------------
    # LIKELIHOOD
    #

    for(i in 1:nReco) {
        sizes[i] ~ dpois(exp(sims[i]))
    }

      


}